Q:exceptの使い方
A:例外を捕まえるため
・数値型と文字列型を+で結合する
・リスト.remove(要素)でリスト内に存在しない要素を削除しようとする
・ディクショナリでget(キー)を用いずに、存在しないキーを指定する
・数値を0で割るゼロ除算
>>> try:
...     a = 10 / 0
... except ZeroDivisionError as e:
...     print("type: {0}".format(type(e)))
...     print("args: {0}".format(e.args))
...     print("msg: {0}".format(e.message))
...     print("{0}".format(e))

else/finally/raiseとも組み合わせ使える
finallyは、例外があるかどうかにも関わらず、行うことである

Q:【正規表現について】HTML tagをマッチするとき、<.*>と<.*?>の違いは何
A:import reにて正規表現のライブラリをインポートする
https://qiita.com/wanwanland/items/ce272419dde2f95cdabc
正規表現の使い方は二つある。
①検索パターンを事前にコンパイルしておく⇒同じパターンは複数検索に最適
pattern = r"xx"
repaser = re.compile(pattern)
matchObj = repaser.match(contents)
②コンパイルせず、パターンを直接に検索時に設定しておく⇒一回のみの場合
pattern = r"xx"
matchObj = re.match(pattern, contents)

貪欲 (greedy) 対非貪欲 (non-greedy)(原文)
正規表現を繰り返す場合、たとえば a* のように、できるだけパターンの多くにマッチするように
動作することになります。この動作は、例えば角括弧で囲まれた HTML タグのような左右対称の
デリミタの対にマッチしようという場合に問題となります。単一の HTML タグにマッチする素朴な
正規表現はうまく動作しません、なぜならば .* は貪欲に動作するからです。
この場合、解決法は非貪欲を示す修飾子 *?, +?, ?? または {m,n}? を利用することです、
これらはテキストに可能な限り 少なく マッチします。上の例では、 '>' は最初の '<' との
マッチ後すぐに '>' を試みま、失敗した場合にはエンジンが文字を先に進め、'>' が毎ステップ再試行されます。
この動作は正しい結果を生み出します。
>>> s = '<html><head><title>Title</title>'
>>> len(s)
32
>>> print(re.match('<.*>', s).span())
(0, 32)
>>> print(re.match('<.*>', s).group())
<html><head><title>Title</title>
>>> print(re.match('<.*?>', s).group())
<html>

Q:静的ソースコード解析ツール
A:pep8とflake8
https://blog-ja.sideci.com/entry/python-lint-pickup-5tools

Q:/data/test配下にある3日間前のファイルの中に、10KBを超えるファイルを削除してください。
A:SHELL--> find . -mtime +3 -size +10k

                        
                        
